import numpy as np
import pandas as pd
from sklearn.metrics import roc_auc_score
from dataset import divide_data
np.random.seed(7)

# TensorFlow and tf.keras
import tensorflow as tf
import keras
from keras.layers import Input, Dense, Dropout
from keras.models import Model
tf.set_random_seed(1)


# Hyper-parameters
EPOCH = 500
BATCH_SIZE = 64
LR = 0.001
K = 5


# first layer : all genes
# second layer : genes that are part of specific pathway
# third layer : output
def make_base_model(n_input, n_hidden):
    inputs = Input(shape=(n_input,))
    x = Dense(n_hidden, activation='relu', kernel_initializer='glorot_normal')(inputs)
    x = Dropout(0.4, seed=1)(x)
    predictions = Dense(1, activation='sigmoid', kernel_initializer='glorot_normal')(x)

    model = Model(inputs=inputs, outputs=predictions)

    # Configure a model for categorical classification.
    model.compile(optimizer=tf.train.AdamOptimizer(LR),
                  loss=keras.losses.binary_crossentropy,
                  metrics=[keras.metrics.binary_accuracy])
    return model


# Zero out weights that do not correspond to GO relation
class ZeroWeights(keras.callbacks.Callback):
    def __init__(self, t):
        super(ZeroWeights, self).__init__()
        self.t = t

    def on_train_begin(self, logs=None):
        self.zero_weights()

    def on_batch_end(self, batch, logs=None):
        self.zero_weights()

    def zero_weights(self):
        w, b = self.model.layers[1].get_weights()
        self.model.layers[1].set_weights([w * self.t, b])


def get_edges(i):
    df = pd.read_csv("pathways/" + str(i) + ".csv", header=None)
    return df.values


# count_processed_rnaseq.csv is generated by the process_NeoALTTO.R script
train, val, test = divide_data('../count_processed_rnaseq.csv', numpy=True, seed=1)

# using numpy arrays
train_data, train_labels = train[:, 1:-2], train[:, -1]
val_data, val_labels = val[:, 1:-2], val[:, -1]
test_data, test_labels = test[:, 1:-2], test[:, -1]

majority = sum(test_labels) / len(test_labels)

acc = []
auc = []
good_models = []
for i in range(100):
    t = get_edges(i)
    callbacks = [
        # Interrupt training if `val_acc` stops improving for over K epochs
        keras.callbacks.EarlyStopping(patience=K, monitor='val_binary_accuracy'),
        ZeroWeights(t),
    ]
    model = make_base_model(t.shape[0], t.shape[1])
    model.fit(train_data, train_labels, epochs=EPOCH, batch_size=BATCH_SIZE, callbacks=callbacks, verbose=0,
              validation_data=(val_data, val_labels))
    y_pred = model.predict(test_data)
    test_loss, test_acc = model.evaluate(test_data, test_labels, verbose=0)
    auc.append(roc_auc_score(test_labels.astype(np.float32), y_pred.flatten()))
    acc.append(test_acc)
    if test_acc > max(majority, 1 - majority):
        print(i, test_acc, auc[-1])
        good_models.append(model)

print("accuracy: ", np.average(acc), np.std(acc))
print("auc: ", np.average(auc), np.std(auc))

all_pred = None
for m in good_models:
    if all_pred is None:
        all_pred = m.predict(test_data).flatten()
    else:
        all_pred = all_pred + m.predict(test_data).flatten()

all_pred = all_pred / len(good_models)
pred = all_pred > 0.5
truth = test_labels > 0.5

pathways_acc = float((pred == truth).sum()) / float(len(test_labels))
print("all acc: ", pathways_acc)
print("all auc: ", roc_auc_score(test_labels.astype(np.float32), all_pred))
print(test_labels)
print(all_pred)